/*
 * Copyright (C) 2004, 2005 Valery Reznic
 * This file is part of the Elf Statifier project
 * 
 * This project is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License.
 * See LICENSE file in the doc directory.
 */

/*
 * This program is "gdb_runner". It's aim to allow gdb to get
 * control BEFORE first loader's instruction executed.
 * The problem that no one is know where kernel will load loader.
 * With exec-shield and randomization it's ever more problematic.
 *
 * Idea is followig:
 * - set breakpoint on the execve
 * - run this program under gdb.
 * - when hit breakpoint gdb will do "single-instruction"
 *   and verify what next instruction is.
 *   When next instruction is "syscall" we are about to exec 
 *   "program of interest".
 *   One more "single-instruction" - and new program is loaded
 *   and waited for gdb. 
 *   Program counter now is REAL loader's entry point. 
 *
 * Implementation notes.
 * 1) This program should be linked static for the following reason:
 *    LD_PRELOAD libraries may interfere. It's not desirable.
 *    I know, I got a huge executable for nothing. If one want one may
 *    rewrite it in assembler (for each platform)
 *
 * 2) This program can't be run "standalone" - on the very begin it'll kill
 *    itself with "PIPE" signal.
 *    I do it in order to help gdb get control without messing with 
 *    looking for address for set breakpoint on.
 *    gdb have to catch this (i.e PIPE) signal with 
 *    'handle SIGPIPE stop nopass'
 *    So, when signal will be sent, gdb get control, 
 *    and gdb_runner will be stopped.
 *    From here gdb can do single-insruction steps.
 *    "nopass" disable delivering signal to the program,
 *    so it will not be killed but coninue executing.
 *
 *) 3) Race condition.
 *    In the first version of this program i use
 *          raise(QUIT) 
 *    to send signal to itself.
 *    And it work. Mostly.
 *    There is race condition here:
 *          raise(QUIT);                     
 *          execve(argv[1], &argv[1], envp)
 *
 *          program:
 *             raise(QUIT);                     
 *          kernel:
 *             verify permission and put signal into queue.
 *
 *    Now, whats going to happen first:
 *    program execute next line (execve) or got signal (catch by gdb) ?
 *
 *    If kernel (i,e gdb) win this race it's ok.
 *    If program - statifier will not work.
 *         
 * 4) How avoid race condition ?
 *   This race condition is possible because signal, sending by raise() 
 *   is asyncron signal. On the other hand signals like SIGBUS, SIGILL,
 *   famous SIGSEGV are syncron (when generated by program and not sended
 *   by raise :)
 *   So, i have to provoke some kind of signal to be happened.
 *   Which one ? SIGSEGV ? Is it reliable cross-platform method,
 *   which will work for differnt linux and libc versions ?
 *   May be exists something safer and simpler ? Yes. It's SIGPIPE.
 *   Idea is following:
 *   - create pipe
 *   - close 'read' end
 *   - write something to the 'write' end 
 *   - enjoi signal
 *
 * 5) Syscall instructions mnemonic (and binary representation)
 *    are changed from one processor to another.
 *    So when gdb looking for this instruction, gdb should take it into account
 */

#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>

int main(int argc, char *argv[], char *envp[])
{
	/* argv[1] - program to be execed. it can has an argument */

	int res;
	int pipes[2];

	if (argc > 2) {
		fprintf(
			stderr,
			"Usage: %s <program> [<arg> ...]\n",
			argv[0]
		);
		_exit(1);
	}

	/* Let us provoke SIGPIPE signal */

	/* Create pipe */
	res = pipe(pipes);
	if (res == -1) {
		fprintf(
			stderr, 
			"%s: can't create pipe. Errno=%d (%s).\n", 
			argv[0],
			errno,
			strerror(errno)
		);
		_exit(1);
	}

	/* Close 'read' end */
	res = close(pipes[0]);
	if (res == -1) {
		fprintf(
			stderr, 
			"%s: can't close fd. Errno=%d (%s).\n", 
			argv[0],
			errno,
			strerror(errno)
		);
		_exit(1);
	}

	/* write to the 'write' end */
	write(pipes[1], "", 1);

	/* 
	 * I got SIGPIPE here
	 * if program run standalone it'll quietly die.
         * Otherwise, (i.e. under gdb control) I'll execute next line
	 */
	execve(argv[1], &argv[1], envp);

	/* 
	 * Shouldn't get here, unless execve failed. 
	 * Give error messsage and exit
	 */
	fprintf(
		stderr, 
		"%s: can't execve '%s'. Errno=%d (%s).\n", 
		argv[0],
		argv[1],
		errno,
		strerror(errno)
	);
	_exit(1);
}
